{"files": [{"isBinary":false,"fileName":"LICENSE","content":"MIT License\n\nCopyright (c) 2018 SebastiÃ¡n Gurin\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"},{"isBinary":false,"fileName":"package.json","content":"{\n  \"name\": \"yamat\",\n  \"version\": \"0.0.14\",\n  \"description\": \"yamat: yet another monorepo administration tool\",\n  \"main\": \"dist/src/index.js\",\n  \"typings\": \"dist/src/index.d.ts\",\n  \"bin\": \"bin/yamat.js\",\n  \"scripts\": {\n    \"watch\": \"tsc --watch\",\n    \"build\": \"tsc\",\n    \"test\": \"ts-node node_modules/jasmine/bin/jasmine\",\n    \"clean\": \"rm -rf node_modules/ package-lock.json\",\n    \"all\": \"npm run clean && npm install && npm run build && npm test\",\n    \"prepare\": \"npm run build\"\n  },\n  \"author\": \"Sebastian Gurin\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"executive\": \"^1.5.13\",\n    \"shelljs\": \"^0.8.2\",\n    \"yargs-parser\": \"^10.0.0\"\n  },\n  \"devDependencies\": {\n    \"@types/jasmine\": \"^2.8.7\",\n    \"@types/node\": \"^10.3.0\",\n    \"@types/shelljs\": \"^0.8.0\",\n    \"jasmine\": \"^3.1.0\",\n    \"ts-node\": \"^6.0.3\",\n    \"typescript\": \"^2.9.1\"\n  },\n  \"repository\": \"https://github.com/cancerberoSgx/yamat\",\n  \"keywords\": [\n    \"monorepo\",\n    \"multiple packages\",\n    \"lerna alternative\",\n    \"lerna\",\n    \"rush\",\n    \"rush alternative\",\n    \"yarn\",\n    \"workspace\",\n    \"npm workspace\",\n    \"yarn workspace\",\n    \"yarn workspaces\",\n    \"yarn workspaces alternative\"\n  ]\n}\n"},{"isBinary":false,"fileName":"bin/yamat.js","content":"#!/usr/bin/env node\nrequire('../dist/src/cli').main()"},{"isBinary":false,"fileName":"spec/usecase1Spec.ts","content":"import {exec, ExecOutputReturnValue, cat, test} from 'shelljs'\nimport { writeFile } from '../src/util';\nimport { unlink, link, UnlinkVersion, run } from '../src';\n\n// important this tests need to be executed serially (jasmine random==false)\ndescribe('use case 1', () => {\n\tlet p: ExecOutputReturnValue\n\n\tit('making sure npm install ../local will create links so we can start working as mono repo without extra tools', () => {\n\t\texpect(exec(`rm -rf project1 && mkdir project1 && cd project1 && npm init -y`).code).toBe(0)\n\n\t\texpect(exec(`\\\\\ncd project1 && mkdir foo && cd foo && npm init -y && \\\\\necho \"module.exports = 'from foo'\"> index.js `\n\t\t).code).toBe(0)\n\t\tp = exec(`\\\\\ncd project1 && mkdir bar && cd bar && npm init -y && npm install --save ../foo && \\\\\necho \"console.log('foo say: '+require('foo'))\"> index.js && node index.js`)\n\t\texpect(p.code).toBe(0)\n\t\texpect(p.stdout).toContain(`foo say: from foo`)\n\n\t\texpect(exec(`cd project1/foo &&  echo \"module.exports = 'different message'\"> index.js`).code).toBe(0)\n\n\t\tp = exec(`cd project1/bar && node index.js`)\n\t\texpect(p.code).toBe(0)\n\t\texpect(p.stdout).toContain(`foo say: different message`)\n\t})\n\n\n\t\n\tit('create other package that depends on var', ()=>{\n\n\t\tp=exec(`\\\\\n\t\tcd project1/bar  && echo \"module.exports.msg = 'msg from foo: '+require('foo')\"> index.js && node index.js`\n\t\t)\n\t\texpect(p.code).toBe(0)\n\t\t// expect(p.stdout).toContain(`me: different message`)\n\t\texpect(exec(`\\\\\ncd project1 && mkdir third && cd third && npm init -y && \\\\\nnpm install --save ../foo ../bar && \\\\\necho \"console.log('third responds: '+require('bar').msg + ' '+ require('foo'))\" > index.js `\n\t\t).code).toBe(0)\n\t\tp = exec(`\\\\\ncd project1/third && node index.js`) \nexpect(p.code).toBe(0)\nexpect(p.stdout).toContain(`third responds: msg from foo: different message different message`)\n\t})\n\n\n\tit('unlink', ()=>{\n\t\twriteFile('project1/yamat.json', `\n\t\t[\n\t\t\t\t{\"name\": \"foo\", \"path\": \"./foo\"}, \n\t\t\t\t{\"name\": \"bar\", \"path\": \"./bar\"},\n\t\t\t\t{\"name\": \"third\", \"path\": \"./third\"}\n\t\t]`)\n\t\texpect(JSON.parse(cat('project1/bar/package.json')).dependencies.foo).toBe(\"file:../foo\")\n\t\texpect(JSON.parse(cat('project1/third/package.json')).dependencies.foo).toBe(\"file:../foo\")\n\t\texpect(JSON.parse(cat('project1/third/package.json')).dependencies.bar).toBe(\"file:../bar\")\n\t\tunlink({rootPath: 'project1'})\n\t\texpect(JSON.parse(cat('project1/bar/package.json')).dependencies.foo).toBe(\"1.0.0\")\n\t\texpect(JSON.parse(cat('project1/third/package.json')).dependencies.foo).toBe(\"1.0.0\")\n\t\texpect(JSON.parse(cat('project1/third/package.json')).dependencies.bar).toBe(\"1.0.0\")\n\t\tlink({rootPath: 'project1'})\n\t\texpect(JSON.parse(cat('project1/bar/package.json')).dependencies.foo).toBe(\"file:../foo\")\n\t\texpect(JSON.parse(cat('project1/third/package.json')).dependencies.foo).toBe(\"file:../foo\")\n\t\texpect(JSON.parse(cat('project1/third/package.json')).dependencies.bar).toBe(\"file:../bar\")\n\n\n\t})\n\n\tit('unlink --version pack', ()=>{\n\t\tunlink({rootPath: 'project1', version: UnlinkVersion.pack})\n\t\texpect(JSON.parse(cat('project1/bar/package.json')).dependencies.foo).toContain(\"project1/.yamat/foo-1.0.0.tgz\")\n\t\texpect(test('-f', JSON.parse(cat('project1/bar/package.json')).dependencies.foo)).toBe(true)\n\t\texpect(JSON.parse(cat('project1/third/package.json')).dependencies.foo).toContain(\"project1/.yamat/foo-1.0.0.tgz\")\n\t\texpect(test('-f', JSON.parse(cat('project1/third/package.json')).dependencies.foo)).toBe(true)\n\t\texpect(JSON.parse(cat('project1/third/package.json')).dependencies.bar).toContain(\"project1/.yamat/bar-1.0.0.tgz\")\n\t\texpect(test('-f', JSON.parse(cat('project1/third/package.json')).dependencies.bar)).toBe(true)\n\t})\n\n\tit('link', ()=>{\n\t})\n\n\tit('run', ()=>{\n\t\trun({rootPath: 'project1', cmd: 'echo \"hello\" && exit 0', breakOnError: true})\n\t\t//TODO: test  --breakOnError=true\n\t})\n\n\n\n\t// following are CLI test - TODO: put this in other file - we dont have time now - taking advantage of exiting test projects\n\tit('CLI yamat run', ()=>{\n\t\tconst p = exec(`\\\\\ncd project1\nnpm i --save-dev ..\nnpx yamat run  'echo \"hello123\" && exit 0' \n\t\t`)\n\t\texpect(p.code).toBe(0)\n\t\texpect(p.stdout).toContain('hello123')\n\t\t//TODO: test --breakOnError=true\n\t})\n\n\t//TODO: CLI - test other commands\n})"},{"isBinary":false,"fileName":"src/cli.ts","content":"import { pwd } from \"shelljs\";\nimport { YamatConfig } from \".\";\nimport { forceLatestDependencies } from \"./force-dependency\";\nimport { link } from \"./link\";\nimport { run } from \"./run\";\nimport { unlink, UnlinkVersion } from \"./unlink\";\nimport { getConfigPath } from \"./util\";\nimport { helpAndExit } from \"./help\";\n\nconst args = require('yargs-parser')(process.argv.slice(2));\n\nexport async function main() {\n  const config: YamatConfig = {\n    rootPath: args.rootPath || pwd().toString(),\n    yamatJsonFile: args.yamatJsonFile\n  }\n  config.yamatJsonFile = getConfigPath(config)\n\n  const firstArg = args._[0]\n  // console.log(`yamat command \"${firstArg}\" called with config: ${JSON.stringify(config)}`)\n\n  if(args.help){\n    helpAndExit(0)\n  }\n  else if (firstArg === 'unlink') {\n    return unlink({ ...config, version: args.version || UnlinkVersion.local })\n  }\n  else if (firstArg === 'run') {\n    const cmd = [].concat(args._).slice(1).join(' ')\n    return run({ ...config, cmd, breakOnError: args.breakOnError !== 'no' })\n  }\n  else if (firstArg === 'forceDependenciesLatest') {\n    return await forceLatestDependencies({ ...config, exclude: args.exclude || 'none' })\n  }\n  else if (firstArg === 'link') {\n    return link(config)\n  }\n  else throw new Error('Incorrect call. TODO: usage instructions')\n}\n"},{"isBinary":false,"fileName":"src/force-dependency.ts","content":"import Executive from 'executive';\nimport { resolve } from \"path\";\nimport { ConfigEntry, YamatConfig } from \"./types\";\nimport { getConfig, getPackagePath, parseJSON, parsePackageJson, writePackageJson, getConfigPath } from \"./util\";\n// import { existsSync } from 'fs';\nconst exec: Executive = require('executive')\n\n// * list all versions of given external dependency used by all managed packages\n// * utilities to make sure all managed projects are using the same version of a given external dependency : ex:\n//   yamat force-dependency-version \"typescript@2.9.1\"\n// * utility similar as before but forcing all packages are using latest version of given external dep - use npm\n//   show ts-simple-ast version. ie : yamat force-dependency-latest typescript\n// * same as before but for all dependencies yamat force-dependencies-latest\n\n\n//TODO: big issue - commands are executed in parallel and the return values are empty because async is handled incorrectly. \nexport interface ForceLatestDependenciesConfig extends YamatConfig {\n  exclude: 'dependencies' | 'dev-dependencies' | 'none'\n}\n\nexport async function forceLatestDependencies(forceConfig: ForceLatestDependenciesConfig): Promise<ForceLatestDependenciesResult[][]> {\n  const results: ForceLatestDependenciesResult[][] = []\n  // if(!existsSync(getConfigPath(forceConfig))){\n  //   return nonYamatProjectForceLatestDependencies(forConfig)\n  // }\n  const config = getConfig(forceConfig)\n  config.forEach(async c => {\n    const pj = parsePackageJson(forceConfig, c.path)\n    if (forceConfig.exclude !== 'dependencies') {\n      const result = await modifyJSONDeps(pj, 'dependencies', forceConfig, c)\n      results.push(result)\n    }\n    if (forceConfig.exclude !== 'dev-dependencies') {\n      const result = await modifyJSONDeps(pj, 'devDependencies', forceConfig, c)\n      results.push(result)\n    }\n    writePackageJson(forceConfig, c.path, pj)\n  })\n  // console.log(`Results of forceLatestDependencies command:\\n${JSON.stringify(results, null, 2)}`) // TODO: console.log should be responsibility of cli\n  return results\n}\n\nexport interface ForceLatestDependenciesResult {\n  errorCause?: string,\n  package: string,\n  newVersion?: string,\n  oldVersion?: string,\n  cmd?: string\n}\n\nasync function modifyJSONDeps(pj: any, propertyName: string, forceConfig: ForceLatestDependenciesConfig, c: ConfigEntry): Promise<ForceLatestDependenciesResult[]> {\n  const config = getConfig(forceConfig)\n  const result: ForceLatestDependenciesResult[] = []\n  Object.keys(pj[propertyName] || {})\n    .filter(d => !config.find(c => c.name === d))\n    .forEach(async d => {\n      const cmd = `npm show ${d} version --json`\n      // console.log(`dependency ${d} executing command ${cmd}`);\n      const p = await exec(cmd)\n      console.log(`dependency ${d} command ${cmd} ended with status ${p.status}`);\n      if (p.status) {\n        result.push({ cmd, package: d, errorCause: `Command \"${cmd}\" failed with return status ${p.status}` })\n        return\n      }\n      const parsed = parseJSON(p.stdout.toString())\n      if (parsed instanceof Error) {\n        result.push({ cmd, package: d, errorCause: `Cannot parse response of \"${cmd}\" command: ${p.stdout.toString()}` })\n        return\n      }\n      const currentVersion = pj[propertyName][d] + ''\n      const parsedVersion = parsed + ''\n      if (!currentVersion.endsWith(parsedVersion)) { // endsWith cause current could have tildes, etc\n        const prefix = resolve(getPackagePath(forceConfig, c.path))\n        const cmd2 = `npm install --no-color --no-progress --prefix \"${prefix}\" ${propertyName === 'dependencies' ? '--save' : '--save-dev'} ${d}@${parsedVersion}`\n\n        // console.log(`dependency ${d} executing command ${cmd2}`);\n        const p2 = await exec(cmd2)\n        console.log(`dependency ${d} command ${cmd2} ended with status ${p2.status}`);\n        if (p2.status) {\n          result.push({ cmd: cmd2, package: d, errorCause: `Command \"${cmd2}\" failed with return status ${p2.status}` })\n          return\n        }\n        result.push({ cmd: cmd2, package: d, newVersion: parsedVersion, oldVersion: currentVersion })\n      }\n    })\n  return result\n}\n\n// function nonYamatProjectForceLatestDependencies(forceConfig: ForceLatestDependenciesConfig):any{\n//   getPackagePath(forceConfig)\n// }"},{"isBinary":false,"fileName":"src/help.ts","content":"export function helpAndExit(code:number=0){\n  help()\n  process.exit(code)\n}\n\nfunction help(){\nconsole.log(`\nUsage examples: \n\nyamat link\n\nyamat unlink [--version pack]\n\nRuns \"npm run build\" command on all packages. Don't break if there's an error and prints a final report\n\nyamat run npm run build \n\nRuns \"npm run build\" command on all packages.  Stop executing in the rest of the packages if there's an error and prints a final report:\n\nyamat --break-on-error no run npm run build \n\nUpgrade all dependencies in al packages to latest version found in npmjs.org: \n\nyamat forceDependenciesLatest\n\n`)\n}"},{"isBinary":false,"fileName":"src/index.ts","content":"// just exports all public types for typings \n\nexport * from './types'\nexport * from './unlink'\nexport * from './link'\nexport * from './run'"},{"isBinary":false,"fileName":"src/link.ts","content":"import { getConfig, writeFile, parsePackageJson, writePackageJson } from \"./util\";\nimport { cat } from \"shelljs\";\nimport { relative, resolve } from \"path\";\nimport { YamatConfig, ConfigEntry } from \"./types\";\n\nexport function link(yamatConfig: YamatConfig) {\n  yamatConfig.rootPath = yamatConfig.rootPath || '.'\n  yamatConfig.rootPath = resolve(yamatConfig.rootPath)\n\n  const config = getConfig(yamatConfig)\n  config.forEach(c => {\n    const pj = parsePackageJson(yamatConfig,   c.path)\n    modifyJSONDeps(pj, 'dependencies', config, c)\n    modifyJSONDeps(pj, 'devDependencies', config, c)\n    writePackageJson(yamatConfig, c.path, pj)\n  });\n  console.log('Packages successfully linked!');\n}\n\nfunction modifyJSONDeps(pj: any, propertyName: string, config: ConfigEntry[], c: ConfigEntry) {\n  Object.keys(pj[propertyName] || {})\n  .filter(d => config.find(c => c.name === d))\n  .forEach(d => {\n    const found = config.find(c => c.name === d)\n    if(found){\n      pj[propertyName][d] = 'file:'+relative(c.path, found.path)\n    }\n  })\n}"},{"isBinary":false,"fileName":"src/pack.ts","content":"import { ConfigEntry, UnlinkConfig } from \".\";\nimport { mkdir, pwd, cd, exec, rm, ls } from \"shelljs\";\nimport { getInternalFolder, getPackagePath } from \"./util\";\nimport { ok } from \"assert\";\nimport { join } from \"path\";\n/**\n * creates the pack file  for given targetConfig and return the path to the tgz\n */\nexport function newone(config: UnlinkConfig, targetConfig: ConfigEntry): string {\n  const cwd = pwd()\n  cd(getInternalFolder(config))\n  rm('-rf', targetConfig.name + '-*.tgz')\n  const p = exec('npm pack ' + getPackagePath(config, targetConfig.path))\n  ok(p.code === 0)\n  const tgzs = ls(targetConfig.name + '-*.tgz')\n  ok(tgzs.length === 1)\n  cd(cwd)\n  return join(getInternalFolder(config), tgzs[0])\n}"},{"isBinary":false,"fileName":"src/run.ts","content":"import { sep } from \"path\";\nimport { cd, exec, pwd } from \"shelljs\";\nimport { YamatConfig } from \".\";\nimport { getConfig } from \"./util\";\n\n/**\n * Runs given command on each package serially. \n *\n * By default it will run them all no matter if there are errors (some command ends with exit code\n * different than zero) and list each commend errors in a final report. If --breakOnError is passed\n * in which case it will break on first commend error and exit with the same command exit code. \n */\nexport function run(runConfig: RunConfig) { // TODO: return RunResult with all report information currenlty printed to stdout\n  console.log(`Running in all packages command : ${JSON.stringify(runConfig)}`);\n  const originalDir = pwd()\n  const config = getConfig(runConfig)\n  const results: { cmd: string, path: string, code: number }[] = []\n  config.forEach(c => {\n    cd(runConfig.rootPath + sep + c.path)\n    const code = exec(runConfig.cmd).code\n    if (code !== 0) {\n      console.error(`ERROR while trying to execute command \"${runConfig.cmd}\" in ${c.path}`)\n      if (runConfig.breakOnError) {\n        process.exit(code)\n      }\n    } else {\n      console.log(`Command \"${runConfig.cmd}\" finish successfully in ${c.path}`)\n    }\n    results.push({ cmd: runConfig.cmd, path: c.path, code })\n    cd(originalDir)\n  })\n  if (results.length && results.find(r => r.code !== 0)) {\n    console.error(`\\nERRORs thrown when executing the following commands on some packages: \n${JSON.stringify(results.filter(r => r.code !== 0), null, 2)}\n    `)\n  } else {\n    console.log(`Command \"${runConfig.cmd}\" successfully run in all packages without errors`);\n  }\n}\n\nexport interface RunConfig extends YamatConfig {\n  cmd: string,\n  breakOnError: boolean\n}"},{"isBinary":false,"fileName":"src/types.ts","content":"\nexport interface YamatConfig {\n  /** path to root project  by default it is pwd() */\n  rootPath?: string\n  /** path to of yamat.json file. by default is pwd()+'yamat.json' */\n  yamatJsonFile?: string\n}\n/** one entry in the array in yamat.json */\nexport interface ConfigEntry {\n  name: string\n  path: string\n}\n"},{"isBinary":false,"fileName":"src/unlink.ts","content":"import { YamatConfig } from \"./types\";\nimport { getConfig, parsePackageJson, writePackageJson, getPackagePath } from \"./util\";\nimport { newone } from \"./pack\";\nimport { resolve, relative, join } from \"path\";\n\nexport enum UnlinkVersion {\n  /** put te version from local package.json. Default */\n  local = 'local',\n  /** build current package with npm pack and point the version to that .tgz */\n  pack = 'pack',\n  /** put the version of latest version of package in npm  */\n  npm = 'npm'\n}\n\nexport interface UnlinkConfig extends YamatConfig {\n  version?: UnlinkVersion\n}\n\nexport function unlink(unlinkConfig: UnlinkConfig) {\n  unlinkConfig.rootPath = unlinkConfig.rootPath || '.'  \n  unlinkConfig.rootPath = resolve(unlinkConfig.rootPath)\n  unlinkConfig.version = unlinkConfig.version || UnlinkVersion.local\n  const config = getConfig(unlinkConfig)\n  config.forEach(c => {\n    const pj = parsePackageJson(unlinkConfig, c.path)\n    modifyJSONDeps(pj, 'dependencies', unlinkConfig)\n    modifyJSONDeps(pj, 'devDependencies', unlinkConfig)\n    writePackageJson(unlinkConfig, c.path, pj)\n  })\n  console.log('Packages successfully un-linked!');\n}\n\nfunction modifyJSONDeps(pj: any, propertyName: string, unlinkConfig: UnlinkConfig) {\n  const config = getConfig(unlinkConfig)\n  Object.keys(pj[propertyName] || {})\n  .filter(d => config.find(c => c.name === d))\n  .forEach(d => {\n    if (unlinkConfig.version === UnlinkVersion.local) {\n      const targetConfig = config.find(c => c.name === d)\n      if(targetConfig){\n        pj[propertyName][d] = parsePackageJson(unlinkConfig, targetConfig.path).version\n      }\n    }\n    else if (unlinkConfig.version === UnlinkVersion.pack) { \n      // TODO: we might be exec npm pack several times for the same package !!! too slow!\n      const targetConfig = config.find(c => c.name === d)\n      if(targetConfig){\n        const targetTgz = resolve(newone(unlinkConfig, targetConfig))\n        // we want absolute urls so dependencies of dependencies inside .tgz work! relative won't work in that case\n        pj[propertyName][d] = targetTgz\n      }\n    }\n    else if (unlinkConfig.version === UnlinkVersion.npm) {\n      throw new Error('Not implemented yet')\n    }\n    else {\n      throw new Error('unlink version unknown ' + unlinkConfig.version)\n    }\n  })\n}\n"},{"isBinary":false,"fileName":"src/util.ts","content":"import { writeFileSync } from 'fs';\nimport { sep, join, resolve } from 'path';\nimport * as shell from 'shelljs';\nimport { cat } from \"shelljs\";\nimport { ConfigEntry, UnlinkConfig } from \".\";\nimport { YamatConfig } from \"./types\";\n\nexport function getConfig(config: YamatConfig): Array<ConfigEntry> {\n  return JSON.parse(cat(getConfigPath(config))) // /TODO: cache\n}\n\nexport function getConfigPath(config: YamatConfig):string{\n  return config.yamatJsonFile || (config.rootPath || shell.pwd()) + '/' + 'yamat.json'\n}\nexport function writeFile(file: string, data: string) {\n  (shell as any).ShellString(data).to(file)\n}\n\nexport function getPackageJsonPath(config: YamatConfig, packagePath: string) {\n  return getPackagePath(config, packagePath) + sep + 'package.json'\n}\n\nexport function getPackagePath(config: YamatConfig, packagePath: string): string {\n  return config.rootPath + sep + packagePath\n}\n\nexport function parsePackageJson(config: YamatConfig, path: string) {\n  return JSON.parse(cat(getPackageJsonPath(config, path)))\n}\n\nexport function writePackageJson(config: YamatConfig, path: string, data: any) {\n  writeFileSync(getPackageJsonPath(config, path), JSON.stringify(data, null, 2))\n}\n\nconst internalFolder = '.yamat'\nexport function getInternalFolder(config: YamatConfig) {\n  const folderPath = join(config.rootPath||'.', internalFolder)\n  if (!shell.test('-d', folderPath)) {\n    shell.mkdir('-p', folderPath)\n  }\n  return resolve(folderPath)\n}\n\nexport function parseJSON(s:string):any{\n  try {\n    return JSON.parse(s)\n  } catch (error) {\n    return error\n  }\n}\n"},{"isBinary":false,"fileName":"TODO.md","content":"# TODO\n\n * \"npm-run command : if users work with npm scipts then would be nice to write \"yamat npm-run build\" instead of current \"yamat\n  run npm run install\"  \n * test cli\n * execute configs in order of dependencies - shouldn't be responsibility of the user\n * yamat init ./package1, foo/package2   etc etc to create the yamat.json file from given pacakges.\n * yamat unlink --version pack --target foo,bar // be able to only modify certain packages, not everyone \n * Alternative `yamat unlink --version npm` will use the latest version found in npmjs.org (so we can test with the actual real thing)\n * yamat unlink --version global to point to the version installed globally - \n * yamat unlink --version=pack to point to npm pack generated file so we are sure the publish will go fine. \n * possible issue : yamat run npm run build: what about dependencies - we should build the roots first and then dependants... \n * license\n * yamat.json - path nor required - if none use name as value\n * npm run test-js\n * yamat run spec\n * should yamat link set dependencies  with ^ ?\n * said we will not but would be nice to be able to  yamat run in parallel if user tells ur to do so, ie: yamat\n  --parallel run npm install\n * dependencies tools to work with no yamat enabled projects - so everybody can use them. \n\n## dependencies utilities\n\n * list all versions of given external dependency used by all managed packages\n * utilities to make sure all managed projects are using the same version of a given external dependency : ex:\n  yamat force-dependency-version \"typescript@2.9.1\"\n * utility similar as before but forcing all packages are using latest version of given external dep - use npm\n  show ts-simple-ast version. ie : yamat force-dependency-latest typescript\n * same as before but for all dependencies yamat force-dependencies-latest"},{"isBinary":false,"fileName":"tsconfig.json","content":"{\n  \"compilerOptions\": {\n    \"target\": \"es2018\",\n    \"module\": \"commonjs\",\n    \"lib\": [\n      \"es2018\"\n    ],\n    \"outDir\": \"./dist\",\n    \"rootDir\": \".\",\n    \"strict\": true,\n    \"strictNullChecks\": true,\n    \"esModuleInterop\": true,\n    \"declaration\": true,\n    \"sourceMap\": true\n  },\n  \"include\": [\n    \"src\",\n    \"spec\"\n  ]\n}"},{"isBinary":false,"fileName":"package-lock.json","content":"{\n  \"name\": \"yamat\",\n  \"version\": \"0.0.13\",\n  \"lockfileVersion\": 1,\n  \"requires\": true,\n  \"dependencies\": {\n    \"@types/events\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/@types/events/-/events-1.2.0.tgz\",\n      \"integrity\": \"sha512-KEIlhXnIutzKwRbQkGWb/I4HFqBuUykAdHgDED6xqwXJfONCjF5VoE0cXEiurh3XauygxzeDzgtXUqvLkxFzzA==\",\n      \"dev\": true\n    },\n    \"@types/glob\": {\n      \"version\": \"5.0.35\",\n      \"resolved\": \"https://registry.npmjs.org/@types/glob/-/glob-5.0.35.tgz\",\n      \"integrity\": \"sha512-wc+VveszMLyMWFvXLkloixT4n0harUIVZjnpzztaZ0nKLuul7Z32iMt2fUFGAaZ4y1XWjFRMtCI5ewvyh4aIeg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@types/events\": \"*\",\n        \"@types/minimatch\": \"*\",\n        \"@types/node\": \"*\"\n      }\n    },\n    \"@types/jasmine\": {\n      \"version\": \"2.8.8\",\n      \"resolved\": \"https://registry.npmjs.org/@types/jasmine/-/jasmine-2.8.8.tgz\",\n      \"integrity\": \"sha512-OJSUxLaxXsjjhob2DBzqzgrkLmukM3+JMpRp0r0E4HTdT1nwDCWhaswjYxazPij6uOdzHCJfNbDjmQ1/rnNbCg==\",\n      \"dev\": true\n    },\n    \"@types/minimatch\": {\n      \"version\": \"3.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/@types/minimatch/-/minimatch-3.0.3.tgz\",\n      \"integrity\": \"sha512-tHq6qdbT9U1IRSGf14CL0pUlULksvY9OZ+5eEgl1N7t+OA3tGvNpxJCzuKQlsNgCVwbAs670L1vcVQi8j9HjnA==\",\n      \"dev\": true\n    },\n    \"@types/node\": {\n      \"version\": \"10.3.2\",\n      \"resolved\": \"https://registry.npmjs.org/@types/node/-/node-10.3.2.tgz\",\n      \"integrity\": \"sha512-9NfEUDp3tgRhmoxzTpTo+lq+KIVFxZahuRX0LHF/9IzKHaWuoWsIrrJ61zw5cnnlGINX8lqJzXYfQTOICS5Q+A==\",\n      \"dev\": true\n    },\n    \"@types/shelljs\": {\n      \"version\": \"0.8.0\",\n      \"resolved\": \"https://registry.npmjs.org/@types/shelljs/-/shelljs-0.8.0.tgz\",\n      \"integrity\": \"sha512-vs1hCC8RxLHRu2bwumNyYRNrU3o8BtZhLysH5A4I98iYmA2APl6R3uNQb5ihl+WiwH0xdC9LLO+vRrXLs/Kyxg==\",\n      \"dev\": true,\n      \"requires\": {\n        \"@types/glob\": \"*\",\n        \"@types/node\": \"*\"\n      }\n    },\n    \"arrify\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/arrify/-/arrify-1.0.1.tgz\",\n      \"integrity\": \"sha1-iYUI2iIm84DfkEcoRWhJwVAaSw0=\",\n      \"dev\": true\n    },\n    \"balanced-match\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.0.tgz\",\n      \"integrity\": \"sha1-ibTRmasr7kneFk6gK4nORi1xt2c=\"\n    },\n    \"brace-expansion\": {\n      \"version\": \"1.1.11\",\n      \"resolved\": \"https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz\",\n      \"integrity\": \"sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==\",\n      \"requires\": {\n        \"balanced-match\": \"^1.0.0\",\n        \"concat-map\": \"0.0.1\"\n      }\n    },\n    \"buffer-from\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.0.tgz\",\n      \"integrity\": \"sha512-c5mRlguI/Pe2dSZmpER62rSCu0ryKmWddzRYsuXc50U2/g8jMOulc31VZMa4mYx31U5xsmSOpDCgH88Vl9cDGQ==\",\n      \"dev\": true\n    },\n    \"camelcase\": {\n      \"version\": \"4.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/camelcase/-/camelcase-4.1.0.tgz\",\n      \"integrity\": \"sha1-1UVjW+HjPFQmScaRc+Xeas+uNN0=\"\n    },\n    \"concat-map\": {\n      \"version\": \"0.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz\",\n      \"integrity\": \"sha1-2Klr13/Wjfd5OnMDajug1UBdR3s=\"\n    },\n    \"diff\": {\n      \"version\": \"3.5.0\",\n      \"resolved\": \"https://registry.npmjs.org/diff/-/diff-3.5.0.tgz\",\n      \"integrity\": \"sha512-A46qtFgd+g7pDZinpnwiRJtxbC1hpgf0uzP3iG89scHk0AUC7A1TGxf5OiiOUv/JMZR8GOt8hL900hV0bOy5xA==\",\n      \"dev\": true\n    },\n    \"executive\": {\n      \"version\": \"1.5.13\",\n      \"resolved\": \"https://registry.npmjs.org/executive/-/executive-1.5.13.tgz\",\n      \"integrity\": \"sha1-IOmi0UYdSG4Ww4NULVAd8nR50aI=\"\n    },\n    \"fs.realpath\": {\n      \"version\": \"1.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz\",\n      \"integrity\": \"sha1-FQStJSMVjKpA20onh8sBQRmU6k8=\"\n    },\n    \"glob\": {\n      \"version\": \"7.1.2\",\n      \"resolved\": \"https://registry.npmjs.org/glob/-/glob-7.1.2.tgz\",\n      \"integrity\": \"sha512-MJTUg1kjuLeQCJ+ccE4Vpa6kKVXkPYJ2mOCQyUuKLcLQsdrMCpBPUi8qVE6+YuaJkozeA9NusTAw3hLr8Xe5EQ==\",\n      \"requires\": {\n        \"fs.realpath\": \"^1.0.0\",\n        \"inflight\": \"^1.0.4\",\n        \"inherits\": \"2\",\n        \"minimatch\": \"^3.0.4\",\n        \"once\": \"^1.3.0\",\n        \"path-is-absolute\": \"^1.0.0\"\n      }\n    },\n    \"inflight\": {\n      \"version\": \"1.0.6\",\n      \"resolved\": \"https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz\",\n      \"integrity\": \"sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=\",\n      \"requires\": {\n        \"once\": \"^1.3.0\",\n        \"wrappy\": \"1\"\n      }\n    },\n    \"inherits\": {\n      \"version\": \"2.0.3\",\n      \"resolved\": \"https://registry.npmjs.org/inherits/-/inherits-2.0.3.tgz\",\n      \"integrity\": \"sha1-Yzwsg+PaQqUC9SRmAiSA9CCCYd4=\"\n    },\n    \"interpret\": {\n      \"version\": \"1.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/interpret/-/interpret-1.1.0.tgz\",\n      \"integrity\": \"sha1-ftGxQQxqDg94z5XTuEQMY/eLhhQ=\"\n    },\n    \"jasmine\": {\n      \"version\": \"3.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/jasmine/-/jasmine-3.1.0.tgz\",\n      \"integrity\": \"sha1-K9Wf1+xuwOistk4J9Fpo7SrRlSo=\",\n      \"dev\": true,\n      \"requires\": {\n        \"glob\": \"^7.0.6\",\n        \"jasmine-core\": \"~3.1.0\"\n      }\n    },\n    \"jasmine-core\": {\n      \"version\": \"3.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/jasmine-core/-/jasmine-core-3.1.0.tgz\",\n      \"integrity\": \"sha1-pHheE11d9lAk38kiSVPfWFvSdmw=\",\n      \"dev\": true\n    },\n    \"make-error\": {\n      \"version\": \"1.3.4\",\n      \"resolved\": \"https://registry.npmjs.org/make-error/-/make-error-1.3.4.tgz\",\n      \"integrity\": \"sha512-0Dab5btKVPhibSalc9QGXb559ED7G7iLjFXBaj9Wq8O3vorueR5K5jaE3hkG6ZQINyhA/JgG6Qk4qdFQjsYV6g==\",\n      \"dev\": true\n    },\n    \"minimatch\": {\n      \"version\": \"3.0.4\",\n      \"resolved\": \"https://registry.npmjs.org/minimatch/-/minimatch-3.0.4.tgz\",\n      \"integrity\": \"sha512-yJHVQEhyqPLUTgt9B83PXu6W3rx4MvvHvSUvToogpwoGDOUQ+yDrR0HRot+yOCdCO7u4hX3pWft6kWBBcqh0UA==\",\n      \"requires\": {\n        \"brace-expansion\": \"^1.1.7\"\n      }\n    },\n    \"minimist\": {\n      \"version\": \"1.2.0\",\n      \"resolved\": \"https://registry.npmjs.org/minimist/-/minimist-1.2.0.tgz\",\n      \"integrity\": \"sha1-o1AIsg9BOD7sH7kU9M1d95omQoQ=\",\n      \"dev\": true\n    },\n    \"mkdirp\": {\n      \"version\": \"0.5.1\",\n      \"resolved\": \"https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.1.tgz\",\n      \"integrity\": \"sha1-MAV0OOrGz3+MR2fzhkjWaX11yQM=\",\n      \"dev\": true,\n      \"requires\": {\n        \"minimist\": \"0.0.8\"\n      },\n      \"dependencies\": {\n        \"minimist\": {\n          \"version\": \"0.0.8\",\n          \"resolved\": \"https://registry.npmjs.org/minimist/-/minimist-0.0.8.tgz\",\n          \"integrity\": \"sha1-hX/Kv8M5fSYluCKCYuhqp6ARsF0=\",\n          \"dev\": true\n        }\n      }\n    },\n    \"once\": {\n      \"version\": \"1.4.0\",\n      \"resolved\": \"https://registry.npmjs.org/once/-/once-1.4.0.tgz\",\n      \"integrity\": \"sha1-WDsap3WWHUsROsF9nFC6753Xa9E=\",\n      \"requires\": {\n        \"wrappy\": \"1\"\n      }\n    },\n    \"path-is-absolute\": {\n      \"version\": \"1.0.1\",\n      \"resolved\": \"https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz\",\n      \"integrity\": \"sha1-F0uSaHNVNP+8es5r9TpanhtcX18=\"\n    },\n    \"path-parse\": {\n      \"version\": \"1.0.5\",\n      \"resolved\": \"https://registry.npmjs.org/path-parse/-/path-parse-1.0.5.tgz\",\n      \"integrity\": \"sha1-PBrfhx6pzWyUMbbqK9dKD/BVxME=\"\n    },\n    \"rechoir\": {\n      \"version\": \"0.6.2\",\n      \"resolved\": \"https://registry.npmjs.org/rechoir/-/rechoir-0.6.2.tgz\",\n      \"integrity\": \"sha1-hSBLVNuoLVdC4oyWdW70OvUOM4Q=\",\n      \"requires\": {\n        \"resolve\": \"^1.1.6\"\n      }\n    },\n    \"resolve\": {\n      \"version\": \"1.7.1\",\n      \"resolved\": \"https://registry.npmjs.org/resolve/-/resolve-1.7.1.tgz\",\n      \"integrity\": \"sha512-c7rwLofp8g1U+h1KNyHL/jicrKg1Ek4q+Lr33AL65uZTinUZHe30D5HlyN5V9NW0JX1D5dXQ4jqW5l7Sy/kGfw==\",\n      \"requires\": {\n        \"path-parse\": \"^1.0.5\"\n      }\n    },\n    \"shelljs\": {\n      \"version\": \"0.8.2\",\n      \"resolved\": \"https://registry.npmjs.org/shelljs/-/shelljs-0.8.2.tgz\",\n      \"integrity\": \"sha512-pRXeNrCA2Wd9itwhvLp5LZQvPJ0wU6bcjaTMywHHGX5XWhVN2nzSu7WV0q+oUY7mGK3mgSkDDzP3MgjqdyIgbQ==\",\n      \"requires\": {\n        \"glob\": \"^7.0.0\",\n        \"interpret\": \"^1.0.0\",\n        \"rechoir\": \"^0.6.2\"\n      }\n    },\n    \"source-map\": {\n      \"version\": \"0.6.1\",\n      \"resolved\": \"https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz\",\n      \"integrity\": \"sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==\",\n      \"dev\": true\n    },\n    \"source-map-support\": {\n      \"version\": \"0.5.6\",\n      \"resolved\": \"https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.6.tgz\",\n      \"integrity\": \"sha512-N4KXEz7jcKqPf2b2vZF11lQIz9W5ZMuUcIOGj243lduidkf2fjkVKJS9vNxVWn3u/uxX38AcE8U9nnH9FPcq+g==\",\n      \"dev\": true,\n      \"requires\": {\n        \"buffer-from\": \"^1.0.0\",\n        \"source-map\": \"^0.6.0\"\n      }\n    },\n    \"ts-node\": {\n      \"version\": \"6.1.0\",\n      \"resolved\": \"https://registry.npmjs.org/ts-node/-/ts-node-6.1.0.tgz\",\n      \"integrity\": \"sha512-mw11Bq08RZgrU/bzcVw/Ti9wNyefpOanXgWsHg008wyVHjvFhWxNatVVrciOAu8BcWSECoNOSunRzUokKH8Mmw==\",\n      \"dev\": true,\n      \"requires\": {\n        \"arrify\": \"^1.0.0\",\n        \"diff\": \"^3.1.0\",\n        \"make-error\": \"^1.1.1\",\n        \"minimist\": \"^1.2.0\",\n        \"mkdirp\": \"^0.5.1\",\n        \"source-map-support\": \"^0.5.6\",\n        \"yn\": \"^2.0.0\"\n      }\n    },\n    \"typescript\": {\n      \"version\": \"2.9.1\",\n      \"resolved\": \"https://registry.npmjs.org/typescript/-/typescript-2.9.1.tgz\",\n      \"integrity\": \"sha512-h6pM2f/GDchCFlldnriOhs1QHuwbnmj6/v7499eMHqPeW4V2G0elua2eIc2nu8v2NdHV0Gm+tzX83Hr6nUFjQA==\",\n      \"dev\": true\n    },\n    \"wrappy\": {\n      \"version\": \"1.0.2\",\n      \"resolved\": \"https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz\",\n      \"integrity\": \"sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8=\"\n    },\n    \"yargs-parser\": {\n      \"version\": \"10.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/yargs-parser/-/yargs-parser-10.0.0.tgz\",\n      \"integrity\": \"sha512-+DHejWujTVYeMHLff8U96rLc4uE4Emncoftvn5AjhB1Jw1pWxLzgBUT/WYbPrHmy6YPEBTZQx5myHhVcuuu64g==\",\n      \"requires\": {\n        \"camelcase\": \"^4.1.0\"\n      }\n    },\n    \"yn\": {\n      \"version\": \"2.0.0\",\n      \"resolved\": \"https://registry.npmjs.org/yn/-/yn-2.0.0.tgz\",\n      \"integrity\": \"sha1-5a2ryKz0CPY4X8dklWhMiOavaJo=\",\n      \"dev\": true\n    }\n  }\n}\n"},{"isBinary":false,"fileName":"Changelog.md","content":"## 0.0.11\n\n * run final report fix\n\n## 0.0.13\n\n * fix --break-on-error no impl and docs\n * yamat forceDependenciesLatest\n * yamat help\n\n ## 0.0.14"},{"isBinary":false,"fileName":"README.md","content":"# yamat: Yet Another Monorepo Administration Tool\n\nTired of the complexities of lerna, rush or yarn workspaces ? This tool solves the problem of mono repos (multiple packages in the same repository) with a very straightforward solution. \n\n * npm based\n * Don't create links just execute npm commands\n * dumb tool - dependency order in configuration file is user's responsibility (will be improved)\n * Don't mess with node_modules\n * Not involved with the development cycle. \n * Just a simple transformation back and forward in versions of your monorepo's `package.json` dependencies. Will never modify anything else but that \n * User is responsible on everything else, publish, versioning, testing\n * User is responsible of setting a **\"prepare\" script** that builds its project accordingly - if not unlink --version pack\n   won't work as well as npm publish \n * User is responsible of correctly ordering dependencies in yamat.json so build doesn't fail\n * KISS. \n * Don't try to be fast. \n * Don't try to save space on your disk. \n * Don't try solve any npm problem. Reuses as much as it can of already existent npm functionality. \n * It's user responsibility to execute `yamat link` when starting development and `yamat unlink` before publishing\n * CLI and node.js API\n\n\n# Commands\n\n## yamat unlink\n\n * **Execute before publishing**. \n * **Will point to numbered dependencies**. \n * `yamat unlink` : will point to the current version number of the local `package.json`. **Ideal for publish all the packages together**.\n * `yamat unlink --version pack` : for each managed dependency will generate a package tarball and point all dependents there. A package tarball (.tgz file) is generated with `npm pack` command and is identical to the result of `npm publish`. **Ideal for testing packages before publishing**\n\n\n## yamat link\n \n * **Execute before start developing** in mono-repo - mode. Will change dependencies pointing to local folders (\"some-package\": \"file:../some-package\"). \"Mono-repo development mode\". \n  For each managed dependency it will point it to a relative filesystem path. Then executes `npm install` (which creates sym links)\n\n## yamat run\n\n * **Runs a command on all packages**. For example `yamat run npm test` will execute `npm test` on each package, serially. If one ends with exit code different than 0 then yamat will also. By default yamat won't execute the command on following packages if one fails.Fr preventing this and run the command on all packages and then give a final report execute with ` --break-on-error no` argument like this: `yamat --break-on-error no run npm test`  . \n\n## yamat forceDependenciesLatest\n\n * Upgrade all dependencies in al packages to latest version found in npmjs.org\n\n## yamat help\n\n * prints help on all comand as examples and exit\n\n\n# Common Publishing workflow \n\n(for impatiens)\n\nImagine you made lots of changes, your tests are green and you feel it's time to increment versions and publish to npm. You want to test against packages identical to the ones that are published. If tests pass, increment version and publish:\n\n```sh\nyamat run npm test \n# tests are passing with dependencies linked in filesystem\n# so now we want to run tests using \"npm pack\" version of dependencies\n# that should be identical to next version of \"npm publish\"\nyamat unlink --version pack\nyamat run npm run clean \nyamat run npm install\nyamat run npm run build\nyamat run npm test\n# OK tests passed using \"npm pack\" version of dependencies\n# let's increment version, point to that new version and publish\nyamat unlink # point dependencies to version declared in local package.json\nyamat run npm version patch # increments version by 0.0.1 of package\nyamat unlink # update dependencies version (incremented with previous command)\nyamat run npm publish\n```\nIf unsure, you could run `yamat unlink --version pack && yamat run npm run clean && yamat run npm install && yamat run npm run build && yamat run npm test && yamat unlink` commands again before the last `npm publish` but IMO not necessary because we already test everything against packed dependencies... Just make sure you run `yamat unlink` before publishing. \n\nSee more detailed examples below. \n\n# Tutorial\n\nlet's create a new mono-repo with two packages inside, foo and bar, and bar depends on foo:\n\n## Initial setup\n\n```sh\nmkdir project1 && cd project1 && npm init -y\nmkdir foo && cd foo && npm init -y && echo \"module.exports = 'from foo'\"> index.js && cd ..\nmkdir bar && cd bar && npm init -y && npm install --save ../foo && echo \"console.log('foo say: '+require('foo'))\"> index.js && cd ..\n```\n\nWe setup both packages - bar points to ../foo. We haven't used yamat yet. \n\nNotice that we are ready to work since bar/node_modules/foo is a symbolic link that npm created Install other dependencies on each internal repository, as usual - on this regard they are independent. \n\nThe problem arises when we start publishing. We want to publish both\n\n## Setup yamat\n\n```sh\nnpm install --save-dev yamat\ncat > yamat.json \n[\n  {\"name\": \"foo\", \"path\": \"./foo\"}, \n  {\"name\": \"bar\", \"path\": \"./bar\"}\n]\n^D \n```\n\n**Important** I defined project foo before bar in the array because bar depends on foo. Because commands run with yamat will run in order and serially, **I'm responsible of ordering packages in yamat.json** so, for example, build don't fail. \n\n\n## First publish\n\n```sh\nyamat unlink\nyamat run npm publish\n```\n\n## Keep developing and publish again\n\n```sh\nyamat link\n# ready to local development. write test compile install, etc\n# now we want to publish all packages again\n\n# make sure tests are green\nyamat run npm test \n\n# build packages with npm pack and point dependencies to them (so is identical to \n# what will happen when we publish)\nyamat unlink --version pack \n\n# run tests again\nyamat run \"npm install && npm run build && npm run test\"\n\n# and if everything is OK increase versions, point dependencies to those new versions and publish\n\n# increment version of each package\nyamat run npm version patch\n\n# point dependencies to version declared in local package.json\nyamat unlink \n\n# publish all packages to npmjs.org. If a package is not meant to be published just \n# add \"private\": false to its package.json. We execute it with  --break-on-error no \n# because private packages will give error if we try to publish them:\nyamat --break-on-error no run npm publish\n\n# link packages locally again to keep developing: \nyamat link\n```\n\n\n# TODO - ROADMAP\n\nsee TODO.md file next to this"},{"isBinary":false,"fileName":"spec/support/jasmine.json","content":"{\n  \"spec_dir\": \"spec\",\n  \"spec_files\": [\n    \"**/*[sS]pec.ts\"\n  ],\n  \"helpers\": [\n    \"helpers/**/*.ts\"\n  ],\n  \"stopSpecOnExpectationFailure\": false,\n  \"random\": false\n}\n"}]}